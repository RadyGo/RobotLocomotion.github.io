<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: QueryObject&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1geometry_1_1_query_object.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdrake_1_1geometry_1_1_query_object-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">QueryObject&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class drake::geometry::QueryObject&lt; T &gt;</h3>

<p>The QueryObject serves as a mechanism to perform geometry queries on the world's geometry. </p>
<p>The <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> has an abstract-valued port that contains a QueryObject (i.e., a QueryObject-valued output port).</p>
<p>To perform geometry queries on <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>:</p><ul>
<li>a LeafSystem must have a QueryObject-valued input port and connect it to the corresponding query output port on <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a>,</li>
<li>the querying LeafSystem can evaluate the input port, retrieving a <code>const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a>&amp;</code> in return, and, finally,</li>
<li>invoke the appropriate method on the QueryObject.</li>
</ul>
<p>The const reference returned by the input port is considered "live" - it is linked to the context, system, and cache (making full use of all of those mechanisms). This const reference should <em>never</em> be persisted; doing so can lead to erroneous query results. It is simpler and more advisable to acquire it for evaluation in a limited scope (e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is needed for many separate functions in a LeafSystem, each should re-evaluate the input port. The underlying caching mechanism should make the cost of this negligible.</p>
<p>The QueryObject <em>can</em> be copied. The copied instance is no longer "live"; it is now "baked". Essentially, it freezes the state of the live scene graph in its current configuration and disconnects it from the system and context. This means, even if the original context changes values, the copied/baked instance will always reproduce the same query results. This baking process is not cheap and should not be done without consideration.</p>
<h2>Queries and scalar type</h2>
<p>A QueryObject <em>cannot</em> be converted to a different scalar type. A QueryObject of scalar type T can only be acquired from the output port of a <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> of type T evaluated on a corresponding Context, also of type T.</p>
<p>QueryObject's support for arbitrary scalar type is incomplete. Not all queries support all scalar types to the same degree. In some cases the level of support is obvious (such as when the query is declared <em>explicitly</em> in terms of a double-valued scalar &ndash; see <a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a5245399cb460fc5a2283c3485bbd566c" title="Computes the penetrations across all pairs of geometries in the world with the penetrations character...">ComputePointPairPenetration()</a>). In other cases, where the query is expressed in terms of scalar <code>T</code>, the query may have restrictions. If a query has restricted scalar support, it is included in the query's documentation.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The scalar type, which must be one of the <a class="el" href="group__default__scalars.html">default nonsymbolic scalars</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/geometry/scene_graph_inspector.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3ead3718ecc338ebf8ffdd60f8206ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#ab3ead3718ecc338ebf8ffdd60f8206ed">QueryObject</a> ()=default</td></tr>
<tr class="memdesc:ab3ead3718ecc338ebf8ffdd60f8206ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a default <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a> (all pointers are null).  <a href="#ab3ead3718ecc338ebf8ffdd60f8206ed">More...</a><br /></td></tr>
<tr class="separator:ab3ead3718ecc338ebf8ffdd60f8206ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd120e4e5cad6f052fd4a17cce5c984"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">SceneGraphInspector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a3bd120e4e5cad6f052fd4a17cce5c984">inspector</a> () const</td></tr>
<tr class="memdesc:a3bd120e4e5cad6f052fd4a17cce5c984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides an inspector for the topological structure of the underlying scene graph data (see <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">SceneGraphInspector</a> for details).  <a href="#a3bd120e4e5cad6f052fd4a17cce5c984">More...</a><br /></td></tr>
<tr class="separator:a3bd120e4e5cad6f052fd4a17cce5c984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Calling the copy constructor or assignment will turn a <em>live</em> QueryObject into a <em>baked</em> QueryObject (an expensive operation).</p>
<p>Copying baked QueryObjects is cheap. </p>
</div></td></tr>
<tr class="memitem:ac84d9a202933205a92cf0823b94ba512"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#ac84d9a202933205a92cf0823b94ba512">QueryObject</a> (const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;other)</td></tr>
<tr class="separator:ac84d9a202933205a92cf0823b94ba512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952bddcf25175beb05e1587cf2c54fbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a952bddcf25175beb05e1587cf2c54fbf">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;)</td></tr>
<tr class="separator:a952bddcf25175beb05e1587cf2c54fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16c29c5b277b7b1aa84d111afca6c55c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a16c29c5b277b7b1aa84d111afca6c55c">QueryObject</a> (<a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a16c29c5b277b7b1aa84d111afca6c55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec44660f5c2d722bfe401a5f5bac76b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a3ec44660f5c2d722bfe401a5f5bac76b">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a3ec44660f5c2d722bfe401a5f5bac76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Pose-dependent Introspection</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide access to introspect geometry and frame quantities that directly depend on the poses of the frames.</p>
<p>For geometry and frame quantities that do not depend on the poses of frames, such as X_FG, use <a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a3bd120e4e5cad6f052fd4a17cce5c984" title="Provides an inspector for the topological structure of the underlying scene graph data (see SceneGrap...">inspector()</a> to access the <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">SceneGraphInspector</a>. </p>
</div></td></tr>
<tr class="memitem:afbaeaa978e4c781e7440dc25f518040b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#afbaeaa978e4c781e7440dc25f518040b">X_WF</a> (<a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> id) const</td></tr>
<tr class="memdesc:afbaeaa978e4c781e7440dc25f518040b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the position of the frame indicated by <code>id</code> relative to the world frame.  <a href="#afbaeaa978e4c781e7440dc25f518040b">More...</a><br /></td></tr>
<tr class="separator:afbaeaa978e4c781e7440dc25f518040b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626f8f4a5b55214d1dfd3c4e385afcc2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a626f8f4a5b55214d1dfd3c4e385afcc2">X_PF</a> (<a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> id) const</td></tr>
<tr class="memdesc:a626f8f4a5b55214d1dfd3c4e385afcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the position of the frame indicated by <code>id</code> relative to its parent frame.  <a href="#a626f8f4a5b55214d1dfd3c4e385afcc2">More...</a><br /></td></tr>
<tr class="separator:a626f8f4a5b55214d1dfd3c4e385afcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8f8876ebb0616b25528e4bc3d86cd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a4e8f8876ebb0616b25528e4bc3d86cd6">X_WG</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> id) const</td></tr>
<tr class="memdesc:a4e8f8876ebb0616b25528e4bc3d86cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the position of the geometry indicated by <code>id</code> relative to the world frame.  <a href="#a4e8f8876ebb0616b25528e4bc3d86cd6">More...</a><br /></td></tr>
<tr class="separator:a4e8f8876ebb0616b25528e4bc3d86cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Collision Queries</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="collision_queries"></a></p>
<p>These queries detect <em>collisions</em> between geometry. Two geometries collide if they overlap each other and are not explicitly excluded through collision filtering. These algorithms find those colliding cases, characterize them, and report the essential characteristics of that collision.</p>
<p>For two colliding geometries g_A and g_B, it is guaranteed that they will map to <code>id_A</code> and <code>id_B</code> in a fixed, repeatable manner, where <code>id_A</code> and <code>id_B</code> are <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html" title="Type used to identify geometry instances in SceneGraph.">GeometryId</a>'s of geometries g_A and g_B respectively.</p>
<p>These methods are affected by collision filtering; element pairs that have been filtered will not produce contacts, even if their collision geometry is penetrating. </p>
</div></td></tr>
<tr class="memitem:a5245399cb460fc5a2283c3485bbd566c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a5245399cb460fc5a2283c3485bbd566c">ComputePointPairPenetration</a> () const</td></tr>
<tr class="memdesc:a5245399cb460fc5a2283c3485bbd566c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the penetrations across all pairs of geometries in the world with the penetrations characterized by pairs of points (see <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries.">PenetrationAsPointPair</a>), providing some measure of the penetration "depth" of the two objects, but <em>not</em> the overlapping volume.  <a href="#a5245399cb460fc5a2283c3485bbd566c">More...</a><br /></td></tr>
<tr class="separator:a5245399cb460fc5a2283c3485bbd566c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55c420d969868c31e1c0e776523c43a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#ae55c420d969868c31e1c0e776523c43a">ComputeContactSurfaces</a> () const</td></tr>
<tr class="memdesc:ae55c420d969868c31e1c0e776523c43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports pairwise intersections and characterizes each non-empty intersection as a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> for hydroelastic contact model.  <a href="#ae55c420d969868c31e1c0e776523c43a">More...</a><br /></td></tr>
<tr class="separator:ae55c420d969868c31e1c0e776523c43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a4d66679fd24b17492c30e938da047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a32a4d66679fd24b17492c30e938da047">ComputeContactSurfacesWithFallback</a> (std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt;&gt; *surfaces, std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; double &gt;&gt; *point_pairs) const</td></tr>
<tr class="memdesc:a32a4d66679fd24b17492c30e938da047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports pair-wise intersections and characterizes each non-empty intersection as a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> <em>where possible</em> and as a <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries.">PenetrationAsPointPair</a> where not.  <a href="#a32a4d66679fd24b17492c30e938da047">More...</a><br /></td></tr>
<tr class="separator:a32a4d66679fd24b17492c30e938da047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48676624208ba13c78edbc098203f1ea"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt; <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a48676624208ba13c78edbc098203f1ea">FindCollisionCandidates</a> () const</td></tr>
<tr class="memdesc:a48676624208ba13c78edbc098203f1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a conservative culling mechanism to create a subset of all possible geometry pairs based on non-zero intersections.  <a href="#a48676624208ba13c78edbc098203f1ea">More...</a><br /></td></tr>
<tr class="separator:a48676624208ba13c78edbc098203f1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f702eb73e7464c00b82974d0c5ff6c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a3f702eb73e7464c00b82974d0c5ff6c9">HasCollisions</a> () const</td></tr>
<tr class="memdesc:a3f702eb73e7464c00b82974d0c5ff6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports true if there are <em>any</em> collisions between unfiltered pairs in the world.  <a href="#a3f702eb73e7464c00b82974d0c5ff6c9">More...</a><br /></td></tr>
<tr class="separator:a3f702eb73e7464c00b82974d0c5ff6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Signed Distance Queries</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="signed_distance_query"></a></p>
<p>These queries provide the signed distance between two objects. Each query has a specific definition of the signed distance being positive, negative, or zero associated with some notions of being outside, inside, or on the boundary.</p>
<p>These queries provide bookkeeping data like geometry id(s) of the geometries involved and the important locations on the boundaries of these geometries.</p>
<p>The signed distance function is a continuous function. Its partial derivatives are continuous almost everywhere. </p>
</div></td></tr>
<tr class="memitem:a0918d61334404a7680145cb882a18d52"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a0918d61334404a7680145cb882a18d52">ComputeSignedDistancePairwiseClosestPoints</a> (const double max_distance=std::numeric_limits&lt; double &gt;::infinity()) const</td></tr>
<tr class="memdesc:a0918d61334404a7680145cb882a18d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distance together with the nearest points across all pairs of geometries in the world.  <a href="#a0918d61334404a7680145cb882a18d52">More...</a><br /></td></tr>
<tr class="separator:a0918d61334404a7680145cb882a18d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df45ca643518e6318a1cd1359e3bca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a2df45ca643518e6318a1cd1359e3bca0">ComputeSignedDistancePairClosestPoints</a> (<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> id_A, <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a> id_B) const</td></tr>
<tr class="memdesc:a2df45ca643518e6318a1cd1359e3bca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a0918d61334404a7680145cb882a18d52" title="Computes the signed distance together with the nearest points across all pairs of geometries in the w...">ComputeSignedDistancePairwiseClosestPoints()</a> which computes the signed distance (and witnesses) between a specific pair of geometries indicated by id.  <a href="#a2df45ca643518e6318a1cd1359e3bca0">More...</a><br /></td></tr>
<tr class="separator:a2df45ca643518e6318a1cd1359e3bca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c7754ca66a8593b182ae990643875c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#aa4c7754ca66a8593b182ae990643875c">ComputeSignedDistanceToPoint</a> (const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;p_WQ, const double threshold=std::numeric_limits&lt; double &gt;::infinity()) const</td></tr>
<tr class="memdesc:aa4c7754ca66a8593b182ae990643875c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed distances and gradients to a query point from each geometry in the scene.  <a href="#aa4c7754ca66a8593b182ae990643875c">More...</a><br /></td></tr>
<tr class="separator:aa4c7754ca66a8593b182ae990643875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Render Queries</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="render_queries"></a></p>
<p>The methods support queries along the lines of "What do I see?" They support simulation of sensors. External entities define a sensor camera &ndash; its extrinsic and intrinsic properties and QueryObject renders into the provided image. </p>
</div></td></tr>
<tr class="memitem:aa910471b2f2238ebdccbb49ea47295cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#aa910471b2f2238ebdccbb49ea47295cc">RenderColorImage</a> (const <a class="el" href="structdrake_1_1geometry_1_1render_1_1_camera_properties.html">render::CameraProperties</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, bool show_window, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af5afae0f791341ac7ad11eb6bcb092bd">systems::sensors::ImageRgba8U</a> *color_image_out) const</td></tr>
<tr class="memdesc:aa910471b2f2238ebdccbb49ea47295cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders an RGB image for the given <code>camera</code> posed with respect to the indicated parent frame P.  <a href="#aa910471b2f2238ebdccbb49ea47295cc">More...</a><br /></td></tr>
<tr class="separator:aa910471b2f2238ebdccbb49ea47295cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfc105838770263cb1e1ca3a6934945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a4cfc105838770263cb1e1ca3a6934945">RenderColorImage</a> (const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html">render::ColorRenderCamera</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af5afae0f791341ac7ad11eb6bcb092bd">systems::sensors::ImageRgba8U</a> *color_image_out) const</td></tr>
<tr class="separator:a4cfc105838770263cb1e1ca3a6934945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f26d9dc01ca23447f25adfa777eecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a02f26d9dc01ca23447f25adfa777eecd">RenderDepthImage</a> (const <a class="el" href="structdrake_1_1geometry_1_1render_1_1_depth_camera_properties.html">render::DepthCameraProperties</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#a0558960d25000bd7cc8607cef2fd223b">systems::sensors::ImageDepth32F</a> *depth_image_out) const</td></tr>
<tr class="memdesc:a02f26d9dc01ca23447f25adfa777eecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a depth image for the given <code>camera</code> posed with respect to the indicated parent frame P.  <a href="#a02f26d9dc01ca23447f25adfa777eecd">More...</a><br /></td></tr>
<tr class="separator:a02f26d9dc01ca23447f25adfa777eecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa611fe62e12ad13ca9ef218844542210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#aa611fe62e12ad13ca9ef218844542210">RenderDepthImage</a> (const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_depth_render_camera.html">render::DepthRenderCamera</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#a0558960d25000bd7cc8607cef2fd223b">systems::sensors::ImageDepth32F</a> *depth_image_out) const</td></tr>
<tr class="separator:aa611fe62e12ad13ca9ef218844542210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68c99e7acc9485b1f50162af507e67e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#ab68c99e7acc9485b1f50162af507e67e">RenderLabelImage</a> (const <a class="el" href="structdrake_1_1geometry_1_1render_1_1_camera_properties.html">render::CameraProperties</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, bool show_window, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af9f2ff2c09bd6626d594951724ed1d9a">systems::sensors::ImageLabel16I</a> *label_image_out) const</td></tr>
<tr class="memdesc:ab68c99e7acc9485b1f50162af507e67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders a label image for the given <code>camera</code> posed with respect to the indicated parent frame P.  <a href="#ab68c99e7acc9485b1f50162af507e67e">More...</a><br /></td></tr>
<tr class="separator:ab68c99e7acc9485b1f50162af507e67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba077b59ee3574bbe9a0a602c14293c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#aba077b59ee3574bbe9a0a602c14293c3">RenderLabelImage</a> (const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html">render::ColorRenderCamera</a> &amp;camera, <a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a> parent_frame, const math::RigidTransformd &amp;X_PC, <a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af9f2ff2c09bd6626d594951724ed1d9a">systems::sensors::ImageLabel16I</a> *label_image_out) const</td></tr>
<tr class="separator:aba077b59ee3574bbe9a0a602c14293c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998dab91802cb89dc5dd460083726203"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a998dab91802cb89dc5dd460083726203">GetRenderEngineByName</a> (const std::string &amp;name) const</td></tr>
<tr class="memdesc:a998dab91802cb89dc5dd460083726203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the named render engine, if it exists.  <a href="#a998dab91802cb89dc5dd460083726203">More...</a><br /></td></tr>
<tr class="separator:a998dab91802cb89dc5dd460083726203"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a09e32deb354fd5ca0cc04c6f6110bcb7"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a09e32deb354fd5ca0cc04c6f6110bcb7">SceneGraph&lt; T &gt;</a></td></tr>
<tr class="separator:a09e32deb354fd5ca0cc04c6f6110bcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4afb6aad87f505d5a5ae0031d1e1a707"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a4afb6aad87f505d5a5ae0031d1e1a707">QueryObjectTest</a></td></tr>
<tr class="separator:a4afb6aad87f505d5a5ae0031d1e1a707"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3ead3718ecc338ebf8ffdd60f8206ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ead3718ecc338ebf8ffdd60f8206ed">&#9670;&nbsp;</a></span>QueryObject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a default <a class="el" href="classdrake_1_1geometry_1_1_query_object.html" title="The QueryObject serves as a mechanism to perform geometry queries on the world&#39;s geometry.">QueryObject</a> (all pointers are null). </p>

</div>
</div>
<a id="ac84d9a202933205a92cf0823b94ba512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84d9a202933205a92cf0823b94ba512">&#9670;&nbsp;</a></span>QueryObject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16c29c5b277b7b1aa84d111afca6c55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16c29c5b277b7b1aa84d111afca6c55c">&#9670;&nbsp;</a></span>QueryObject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae55c420d969868c31e1c0e776523c43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae55c420d969868c31e1c0e776523c43a">&#9670;&nbsp;</a></span>ComputeContactSurfaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt;T&gt; &gt; ComputeContactSurfaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports pairwise intersections and characterizes each non-empty intersection as a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> for hydroelastic contact model. </p>
<p>The computation is subject to collision filtering.</p>
<p>For two intersecting geometries g_A and g_B, it is guaranteed that they will map to <code>id_A</code> and <code>id_B</code> in a fixed, repeatable manner, where <code>id_A</code> and <code>id_B</code> are <a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html" title="Type used to identify geometry instances in SceneGraph.">GeometryId</a>'s of geometries g_A and g_B respectively.</p>
<p>In the current incarnation, this function represents a simple implementation.</p>
<ul>
<li>This table shows the supported shapes and compliance modes.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter"><a class="el" href="classdrake_1_1geometry_1_1_shape.html" title="The base interface for all shape specifications.">Shape</a>  </th><th class="markdownTableHeadCenter">Soft  </th><th class="markdownTableHeadLeft">Rigid   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_sphere.html" title="Definition of sphere.">Sphere</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyLeft">yes   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_cylinder.html" title="Definition of a cylinder.">Cylinder</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyLeft">yes   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_box.html" title="Definition of a box.">Box</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyLeft">yes   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_capsule.html" title="Definition of a capsule.">Capsule</a>  </td><td class="markdownTableBodyCenter">no  </td><td class="markdownTableBodyLeft">no   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_ellipsoid.html" title="Definition of an ellipsoid.">Ellipsoid</a>  </td><td class="markdownTableBodyCenter">yes  </td><td class="markdownTableBodyLeft">yes   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_half_space.html" title="Definition of a half space.">HalfSpace</a>  </td><td class="markdownTableBodyCenter">no  </td><td class="markdownTableBodyLeft">no   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Limited support for meshes.">Mesh</a>  </td><td class="markdownTableBodyCenter">no  </td><td class="markdownTableBodyLeft">yes   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Support for convex shapes.">Convex</a>  </td><td class="markdownTableBodyCenter">no  </td><td class="markdownTableBodyLeft">no   </td></tr>
</table>
<ul>
<li>One geometry must be soft, and the other must be rigid. There is no support for soft-soft collision or rigid-rigid collision. If such pairs collide, an exception will be thrown. More particularly, if such a pair <em>cannot be culled</em> an exception will be thrown. No exception is thrown if the pair has been filtered.</li>
<li>The elasticity modulus E (N/m^2) of each geometry is set in <a class="el" href="classdrake_1_1geometry_1_1_proximity_properties.html" title="The set of properties for geometry used in a proximity role.">ProximityProperties</a> (see <a class="el" href="namespacedrake_1_1geometry.html#a75b8bc3ef835424639b5aa5e0874121b">AddContactMaterial()</a>).</li>
<li>The tessellation of the corresponding meshes is controlled by the resolution hint, as defined by <a class="el" href="namespacedrake_1_1geometry.html#ab8c01c8e61753cdc77272c430c452968" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddSoftHydroelasticProperties()</a> and <a class="el" href="namespacedrake_1_1geometry.html#af76ed94bef3f81765a1b3ce069562e00" title="Adds properties to the given set of proximity properties sufficient to cause the associated geometry ...">AddRigidHydroelasticProperties()</a>.</li>
</ul>
<h3>Scalar support</h3>
<p>This method provides support only for double. Attempting to invoke this method with T = AutoDiffXd will throw an exception if there are <em>any</em> geometry pairs that couldn't be culled.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector populated with all detected intersections characterized as contact surfaces. </dd></dl>

</div>
</div>
<a id="a32a4d66679fd24b17492c30e938da047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a4d66679fd24b17492c30e938da047">&#9670;&nbsp;</a></span>ComputeContactSurfacesWithFallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ComputeContactSurfacesWithFallback </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html">ContactSurface</a>&lt; T &gt;&gt; *&#160;</td>
          <td class="paramname"><em>surfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt; double &gt;&gt; *&#160;</td>
          <td class="paramname"><em>point_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports pair-wise intersections and characterizes each non-empty intersection as a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> <em>where possible</em> and as a <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries.">PenetrationAsPointPair</a> where not. </p>
<p>This is a hybrid contact algorithm. It allows for the contact surface penetration result where possible, but automatically provides a fallback for where a <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> cannot be defined.</p>
<p>The fallback cannot guarantee success in all cases. Meshes have limited support in the proximity role; they are supported in the contact surface computation but <em>ignored</em> in the point pair collision query. If a mesh is in contact with another shape that <em>cannot</em> be resolved as a contact surface (e.g., rigid mesh vs another rigid shape), this computation will throw as there is no fallback functionality for mesh-shape.</p>
<p>Because point pairs can only be computed for double-valued systems, this can also only support double-valued <a class="el" href="classdrake_1_1geometry_1_1_contact_surface.html" title="The ContactSurface characterizes the intersection of two geometries M and N as a contact surface with...">ContactSurface</a> instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">surfaces</td><td>The vector that contact surfaces will be added to. The vector will <em>not</em> be cleared. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">point_pairs</td><td>The vector that fall back point pair data will be added to. The vector will <em>not</em> be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>Neither <code>surfaces</code> nor <code>point_pairs</code> is nullptr. </dd></dl>

</div>
</div>
<a id="a5245399cb460fc5a2283c3485bbd566c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5245399cb460fc5a2283c3485bbd566c">&#9670;&nbsp;</a></span>ComputePointPairPenetration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html">PenetrationAsPointPair</a>&lt;double&gt; &gt; ComputePointPairPenetration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the penetrations across all pairs of geometries in the world with the penetrations characterized by pairs of points (see <a class="el" href="structdrake_1_1geometry_1_1_penetration_as_point_pair.html" title="A characterization of the intersection of two penetrating geometries.">PenetrationAsPointPair</a>), providing some measure of the penetration "depth" of the two objects, but <em>not</em> the overlapping volume. </p>
<p>Only reports results for <em>penetrating</em> geometries; if two geometries are separated, there will be no result for that pair. Geometries whose surfaces are just touching (osculating) are not considered in penetration. Surfaces whose penetration is within an epsilon of osculation, are likewise not considered penetrating. Pairs of <em>anchored</em> geometry are also not reported. This method is affected by collision filtering.</p>
<p>For two penetrating geometries g_A and g_B, it is guaranteed that they will map to <code>id_A</code> and <code>id_B</code> in a fixed, repeatable manner.</p>
<h3>Scalar support</h3>
<p>This method only provides double-valued penetration results.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector populated with all detected penetrations characterized as point pairs. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This silently ignores <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Limited support for meshes.">Mesh</a> geometries (but <a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Support for convex shapes.">Convex</a> mesh geometries are included). </dd></dl>

</div>
</div>
<a id="a2df45ca643518e6318a1cd1359e3bca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df45ca643518e6318a1cd1359e3bca0">&#9670;&nbsp;</a></span>ComputeSignedDistancePairClosestPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt;T&gt; ComputeSignedDistancePairClosestPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td>
          <td class="paramname"><em>id_A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td>
          <td class="paramname"><em>id_B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A variant of <a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a0918d61334404a7680145cb882a18d52" title="Computes the signed distance together with the nearest points across all pairs of geometries in the w...">ComputeSignedDistancePairwiseClosestPoints()</a> which computes the signed distance (and witnesses) between a specific pair of geometries indicated by id. </p>
<p>This function has the same restrictions on scalar report as <a class="el" href="classdrake_1_1geometry_1_1_query_object.html#a0918d61334404a7680145cb882a18d52" title="Computes the signed distance together with the nearest points across all pairs of geometries in the w...">ComputeSignedDistancePairwiseClosestPoints()</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">if</td><td>either geometry id is invalid, or if the pair (id_A, id_B) has been marked as filtered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0918d61334404a7680145cb882a18d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0918d61334404a7680145cb882a18d52">&#9670;&nbsp;</a></span>ComputeSignedDistancePairwiseClosestPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structdrake_1_1geometry_1_1_signed_distance_pair.html">SignedDistancePair</a>&lt;T&gt; &gt; ComputeSignedDistancePairwiseClosestPoints </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_distance</em> = <code>std::numeric_limits&lt;&#160;double&#160;&gt;::infinity()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distance together with the nearest points across all pairs of geometries in the world. </p>
<p>Reports both the separating geometries and penetrating geometries.</p>
<p>This query provides φ(A, B), the signed distance between two objects A and B.</p>
<p>If the objects do not overlap (i.e., A ⋂ B = ∅), φ &gt; 0 and represents the minimal distance between the two objects. More formally: φ = min(|Aₚ - Bₚ|) ∀ Aₚ ∈ A and Bₚ ∈ B. </p><dl class="section note"><dt>Note</dt><dd>The pair (Aₚ, Bₚ) is a "witness" of the distance. The pair need not be unique (think of two parallel planes).</dd></dl>
<p>If the objects touch or overlap (i.e., A ⋂ B ≠ ∅), φ ≤ 0 and can be interpreted as the negative penetration depth. It is the smallest length of the vector v, such that by shifting one object along that vector relative to the other, the two objects will no longer be overlapping. More formally, φ(A, B) = -min |v|. s.t (Tᵥ · A) ⋂ B = ∅ where Tᵥ is a rigid transformation that displaces A by the vector v, namely Tᵥ · A = {u + v | ∀ u ∈ A}. By implication, there exist points Aₚ and Bₚ on the surfaces of objects A and B, respectively, such that Aₚ + v = Bₚ, Aₚ ∈ A ∩ B, Bₚ ∈ A ∩ B. These points are the witnesses to the penetration.</p>
<p>This method is affected by collision filtering; geometry pairs that have been filtered will not produce signed distance query results.</p>
<p>For a geometry pair (A, B), the returned results will always be reported in a fixed order (e.g., always (A, B) and never (B, A)). The <em>basis</em> for the ordering is arbitrary (and therefore undocumented), but guaranteed to be fixed and repeatable.</p>
<p>Notice that this is an O(N²) operation, where N is the number of geometries remaining in the world after applying collision filter. We report the distance between dynamic objects, and between dynamic and anchored objects. We DO NOT report the distance between two anchored objects.</p>
<h3>Scalar support</h3>
<p>This function does not support halfspaces. If an unfiltered pair contains a halfspace, an exception will be thrown for all scalar types. Otherwise, this query supports all other pairs of Drake geometry types for <code>double</code>. For <code>AutoDiffXd</code>, it only supports distance between sphere-box and sphere-sphere. If there are any unfiltered geometry pairs that include other geometries, the AutoDiff throws an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_distance</td><td>The maximum distance at which distance data is reported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed distance (and supporting data) for all unfiltered geometry pairs whose distance is less than or equal to <code>max_distance</code>. </dd></dl>

</div>
</div>
<a id="aa4c7754ca66a8593b182ae990643875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c7754ca66a8593b182ae990643875c">&#9670;&nbsp;</a></span>ComputeSignedDistanceToPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html">SignedDistanceToPoint</a>&lt;T&gt; &gt; ComputeSignedDistanceToPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_WQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>std::numeric_limits&lt;&#160;double&#160;&gt;::infinity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed distances and gradients to a query point from each geometry in the scene. </p>
<dl class="section warning"><dt>Warning</dt><dd>Currently supports spheres, boxes, and cylinders only. Silently ignores other kinds of geometries, which will be added later.</dd></dl>
<p>This query provides φᵢ(p), φᵢ:ℝ³→ℝ, the signed distance to the position p of a query point from geometry Gᵢ in the scene. It returns an array of the signed distances from all geometries.</p>
<p>Optionally you can specify a threshold distance that will filter out any object beyond the threshold. By default, we report distances from the query point to every object.</p>
<p>This query also provides the gradient vector ∇φᵢ(p) of the signed distance function from geometry Gᵢ. Note that, in general, if p is outside Gᵢ, then ∇φᵢ(p) equals the unit vector in the direction from the nearest point Nᵢ on Gᵢ's surface to p. If p is inside Gᵢ, then ∇φᵢ(p) is in the direction from p to Nᵢ. This observation is written formally as:</p>
<p>∇φᵢ(p) = (p - Nᵢ)/|p - Nᵢ| if p is outside Gᵢ</p>
<p>∇φᵢ(p) = -(p - Nᵢ)/|p - Nᵢ| if p is inside Gᵢ</p>
<p>Note that ∇φᵢ(p) is also defined on Gᵢ's surface, but we cannot use the above formula.</p>
<h3>Scalar support</h3>
<p>This query only supports computing distances from the point to spheres, boxes, and cylinders for both <code>double</code> and <code>AutoDiffXd</code> scalar types. If the <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html" title="SceneGraph serves as the nexus for all geometry (and geometry-based operations) in a Diagram.">SceneGraph</a> contains any other geometry shapes, they will be silently ignored.</p>
<dl class="section note"><dt>Note</dt><dd>For a sphere G, the signed distance function φᵢ(p) has an undefined gradient vector at the center of the sphere&ndash;every point on the sphere's surface has the same distance to the center. In this case, we will assign ∇φᵢ(p) the unit vector Gx (x-directional vector of G's frame) expressed in World frame.</dd>
<dd>
For a box, at a point p on an edge or a corner of the box, the signed distance function φᵢ(p) has an undefined gradient vector. In this case, we will assign a unit vector in the direction of the average of the outward face unit normals of the incident faces of the edge or the corner. A point p is considered being on a face, or an edge, or a corner of the box if it lies within a certain tolerance from them.</dd>
<dd>
For a box B, if a point p is inside the box, and it is equidistant to to multiple nearest faces, the signed distance function φᵢ(p) at p will have an undefined gradient vector. There is a nearest point candidate associated with each nearest face. In this case, we arbitrarily pick the point Nᵢ associated with one of the nearest faces. Please note that, due to the possible round off error arising from applying a pose X_WG to B, there is no guarantee which of the nearest faces will be used.</dd>
<dd>
The signed distance function is a continuous function with respect to the position of the query point, but its gradient vector field may not be continuous. Specifically at a position equidistant to multiple nearest points, its gradient vector field is not continuous.</dd>
<dd>
For a convex object, outside the object at positive distance from the boundary, the signed distance function is smooth (having continuous first-order partial derivatives).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_WQ</td><td>Position of a query point Q in world frame W. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>We ignore any object beyond this distance. By default, it is infinity, so we report distances from the query point to every object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">signed_distances</td><td>A vector populated with per-object signed distance values (and supporting data). See <a class="el" href="structdrake_1_1geometry_1_1_signed_distance_to_point.html" title="The data for reporting the signed distance from a query point to a geometry.">SignedDistanceToPoint</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48676624208ba13c78edbc098203f1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48676624208ba13c78edbc098203f1ea">&#9670;&nbsp;</a></span>FindCollisionCandidates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structdrake_1_1_sorted_pair.html">SortedPair</a>&lt;<a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&gt; &gt; FindCollisionCandidates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a conservative culling mechanism to create a subset of all possible geometry pairs based on non-zero intersections. </p>
<p>A geometry pair that is <em>absent</em> from the results is either a) culled by collision filters or b) <em>known</em> to be separated. The caller is responsible for confirming that the remaining, unculled geometry pairs are <em>actually</em> in collision.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector populated with collision pair candidates. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This silently ignores <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Limited support for meshes.">Mesh</a> geometries (but <a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Support for convex shapes.">Convex</a> mesh geometries are included). </dd></dl>

</div>
</div>
<a id="a998dab91802cb89dc5dd460083726203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998dab91802cb89dc5dd460083726203">&#9670;&nbsp;</a></span>GetRenderEngineByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_render_engine.html">render::RenderEngine</a>* GetRenderEngineByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the named render engine, if it exists. </p>
<p>The RenderEngine is guaranteed to be up to date w.r.t. the poses and data in the context. </p>

</div>
</div>
<a id="a3f702eb73e7464c00b82974d0c5ff6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f702eb73e7464c00b82974d0c5ff6c9">&#9670;&nbsp;</a></span>HasCollisions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasCollisions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports true if there are <em>any</em> collisions between unfiltered pairs in the world. </p>
<dl class="section warning"><dt>Warning</dt><dd>This silently ignores <a class="el" href="classdrake_1_1geometry_1_1_mesh.html" title="Limited support for meshes.">Mesh</a> geometries (but <a class="el" href="classdrake_1_1geometry_1_1_convex.html" title="Support for convex shapes.">Convex</a> mesh geometries are included). </dd></dl>

</div>
</div>
<a id="a3bd120e4e5cad6f052fd4a17cce5c984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd120e4e5cad6f052fd4a17cce5c984">&#9670;&nbsp;</a></span>inspector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html">SceneGraphInspector</a>&lt;T&gt;&amp; inspector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides an inspector for the topological structure of the underlying scene graph data (see <a class="el" href="classdrake_1_1geometry_1_1_scene_graph_inspector.html" title="The SceneGraphInspector serves as a mechanism to query the topological structure of a SceneGraph inst...">SceneGraphInspector</a> for details). </p>

</div>
</div>
<a id="a952bddcf25175beb05e1587cf2c54fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952bddcf25175beb05e1587cf2c54fbf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ec44660f5c2d722bfe401a5f5bac76b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec44660f5c2d722bfe401a5f5bac76b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa910471b2f2238ebdccbb49ea47295cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa910471b2f2238ebdccbb49ea47295cc">&#9670;&nbsp;</a></span>RenderColorImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderColorImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1render_1_1_camera_properties.html">render::CameraProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&#160;</td>
          <td class="paramname"><em>parent_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;&#160;</td>
          <td class="paramname"><em>X_PC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af5afae0f791341ac7ad11eb6bcb092bd">systems::sensors::ImageRgba8U</a> *&#160;</td>
          <td class="paramname"><em>color_image_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders an RGB image for the given <code>camera</code> posed with respect to the indicated parent frame P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">camera</td><td>The intrinsic properties of the camera. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent_frame</td><td>The id for the camera's parent frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">X_PC</td><td>The pose of the camera body in the world frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">show_window</td><td>If true, the render window will be displayed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">color_image_out</td><td>The rendered color image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4cfc105838770263cb1e1ca3a6934945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfc105838770263cb1e1ca3a6934945">&#9670;&nbsp;</a></span>RenderColorImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderColorImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html">render::ColorRenderCamera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&#160;</td>
          <td class="paramname"><em>parent_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;&#160;</td>
          <td class="paramname"><em>X_PC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af5afae0f791341ac7ad11eb6bcb092bd">systems::sensors::ImageRgba8U</a> *&#160;</td>
          <td class="paramname"><em>color_image_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02f26d9dc01ca23447f25adfa777eecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f26d9dc01ca23447f25adfa777eecd">&#9670;&nbsp;</a></span>RenderDepthImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderDepthImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1render_1_1_depth_camera_properties.html">render::DepthCameraProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&#160;</td>
          <td class="paramname"><em>parent_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;&#160;</td>
          <td class="paramname"><em>X_PC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#a0558960d25000bd7cc8607cef2fd223b">systems::sensors::ImageDepth32F</a> *&#160;</td>
          <td class="paramname"><em>depth_image_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a depth image for the given <code>camera</code> posed with respect to the indicated parent frame P. </p>
<p>In contrast to the other rendering methods, rendering depth images doesn't provide the option to display the window; generally, basic depth images are not readily communicative to humans.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">camera</td><td>The intrinsic properties of the camera. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent_frame</td><td>The id for the camera's parent frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">X_PC</td><td>The pose of the camera body in the world frame. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">depth_image_out</td><td>The rendered depth image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa611fe62e12ad13ca9ef218844542210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa611fe62e12ad13ca9ef218844542210">&#9670;&nbsp;</a></span>RenderDepthImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderDepthImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_depth_render_camera.html">render::DepthRenderCamera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&#160;</td>
          <td class="paramname"><em>parent_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;&#160;</td>
          <td class="paramname"><em>X_PC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#a0558960d25000bd7cc8607cef2fd223b">systems::sensors::ImageDepth32F</a> *&#160;</td>
          <td class="paramname"><em>depth_image_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab68c99e7acc9485b1f50162af507e67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68c99e7acc9485b1f50162af507e67e">&#9670;&nbsp;</a></span>RenderLabelImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderLabelImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdrake_1_1geometry_1_1render_1_1_camera_properties.html">render::CameraProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&#160;</td>
          <td class="paramname"><em>parent_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;&#160;</td>
          <td class="paramname"><em>X_PC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af9f2ff2c09bd6626d594951724ed1d9a">systems::sensors::ImageLabel16I</a> *&#160;</td>
          <td class="paramname"><em>label_image_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders a label image for the given <code>camera</code> posed with respect to the indicated parent frame P. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">camera</td><td>The intrinsic properties of the camera. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">parent_frame</td><td>The id for the camera's parent frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">X_PC</td><td>The pose of the camera body in the world frame. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">show_window</td><td>If true, the render window will be displayed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">label_image_out</td><td>The rendered label image. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba077b59ee3574bbe9a0a602c14293c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba077b59ee3574bbe9a0a602c14293c3">&#9670;&nbsp;</a></span>RenderLabelImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RenderLabelImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1render_1_1_color_render_camera.html">render::ColorRenderCamera</a> &amp;&#160;</td>
          <td class="paramname"><em>camera</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&#160;</td>
          <td class="paramname"><em>parent_frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const math::RigidTransformd &amp;&#160;</td>
          <td class="paramname"><em>X_PC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1systems_1_1sensors.html#af9f2ff2c09bd6626d594951724ed1d9a">systems::sensors::ImageLabel16I</a> *&#160;</td>
          <td class="paramname"><em>label_image_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a626f8f4a5b55214d1dfd3c4e385afcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a626f8f4a5b55214d1dfd3c4e385afcc2">&#9670;&nbsp;</a></span>X_PF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt;&amp; X_PF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the position of the frame indicated by <code>id</code> relative to its parent frame. </p>
<p>If the frame was registered with the world frame as its parent frame, this value will be identical to that returned by <a class="el" href="classdrake_1_1geometry_1_1_query_object.html#afbaeaa978e4c781e7440dc25f518040b" title="Reports the position of the frame indicated by id relative to the world frame.">X_WF()</a>. </p><dl class="section note"><dt>Note</dt><dd>This is analogous to but distinct from SceneGraphInspector::X_PG(). In this case, the pose will <em>always</em> be relative to another frame. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the frame <code>id</code> is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbaeaa978e4c781e7440dc25f518040b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaeaa978e4c781e7440dc25f518040b">&#9670;&nbsp;</a></span>X_WF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt;&amp; X_WF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedrake_1_1geometry.html#a43b41363b37fadf8cce0977d500e13cb">FrameId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the position of the frame indicated by <code>id</code> relative to the world frame. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the frame <code>id</code> is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e8f8876ebb0616b25528e4bc3d86cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8f8876ebb0616b25528e4bc3d86cd6">&#9670;&nbsp;</a></span>X_WG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt;T&gt;&amp; X_WG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_geometry_id.html">GeometryId</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the position of the geometry indicated by <code>id</code> relative to the world frame. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if the geometry <code>id</code> is not valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4afb6aad87f505d5a5ae0031d1e1a707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4afb6aad87f505d5a5ae0031d1e1a707">&#9670;&nbsp;</a></span>QueryObjectTest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class QueryObjectTest</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09e32deb354fd5ca0cc04c6f6110bcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e32deb354fd5ca0cc04c6f6110bcb7">&#9670;&nbsp;</a></span>SceneGraph&lt; T &gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classdrake_1_1geometry_1_1_scene_graph.html">SceneGraph</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/<a class="el" href="query__object_8h.html">query_object.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classdrake_1_1geometry_1_1_query_object.html">QueryObject</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
