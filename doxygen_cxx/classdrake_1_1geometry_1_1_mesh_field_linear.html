<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Drake: MeshFieldLinear&lt; T, MeshType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Drake
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdrake_1_1geometry_1_1_mesh_field_linear.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdrake_1_1geometry_1_1_mesh_field_linear-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MeshFieldLinear&lt; T, MeshType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T, class MeshType&gt;<br />
class drake::geometry::MeshFieldLinear&lt; T, MeshType &gt;</h3>

<p>MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or tetrahedral) mesh; the field value changes linearly within each element E (triangle or tetrahedron), and the gradient ∇f is constant within each element. </p>
<p>The field is continuous across adjacent elements, but its gradient is discontinuous from one element to the other.</p>
<p>To represent a piecewise linear field f, we store one field value per vertex of the mesh. Each element E (triangle or tetrahedron) has (d+1) vertices, where d is the dimension of the element. For triangle, d = 2, and for tetrahedron, d = 3.</p>
<p>On each element E, we define a linear function fᵉ:ℝ³→ℝ using the field values at vertices of E. The gradient ∇fᵉ:ℝ³→ℝ³ is a constant map, so we write ∇fᵉ for the constant gradient vector on E as well. For a point Q in element E, we have: </p><pre class="fragment">   f(Q) = fᵉ(Q) for Q ∈ E,
  ∇f(Q) = ∇fᵉ for Q ∈ E.
</pre><p>Notice that the domain of fᵉ is the entire space of ℝ³, while the domain of f is the underlying space of the mesh.</p>
<p>The following sections are details for interested readers.</p>
<h3>Barycentric coordinate </h3>
<p>For a linear triangle or tetrahedron element E in 3-D, we use barycentric coordinate: </p><pre class="fragment">  (b₀, b₁, b₂)     for triangle,
  (b₀, b₁, b₂, b₃) for tetrahedron,
  ∑bᵢ = 1, bᵢ ≥ 0,
</pre><p>to identify a point Q that lies in the simplicial element E. The coefficient bᵢ is the weight of vertex Vᵉᵢ of the element E, where the index i is a local index within the element E, not the global index of the entire mesh. In other words, vertex Vᵉᵢ is the iᵗʰ vertex of E, not the iᵗʰ vertex among all vertices in the mesh. The point Q in E can be expressed as: </p><pre class="fragment">  Q = ∑bᵉᵢ(Q)Vᵉᵢ,
</pre><p>where we indicate the barycentric coordinate of a point Q on an element E as bᵉᵢ(Q).</p>
<h3>Field value from barycentric coordinates </h3>
<p>At a point Q in element E, the piecewise linear field f has value: </p><pre class="fragment">  f(Q) = fᵉ(Q) = ∑bᵉᵢ(Q)Fᵉᵢ
</pre><p>where Fᵉᵢ is the field value at the iᵗʰ vertex of element E.</p>
<h3>Gradient </h3>
<p>Consider each bᵉᵢ:ℝ³→ℝ as a linear function, its gradient ∇bᵉᵢ:ℝ³→ℝ³ is a constant map, and we write ∇bᵉᵢ for the constant gradient vector. The gradient of the piecewise linear field f at a point Q in an element E is: </p><pre class="fragment">  ∇f(Q) = ∇fᵉ = ∑Fᵉᵢ∇bᵉᵢ.
</pre><h3>Field value from Cartesian coordinates </h3>
<p>At a point Q in element E, the piecewise linear field f has value: </p><pre class="fragment">  f(Q) = ∇fᵉ⋅Q + fᵉ(0,0,0).
</pre><p>Notice that (0,0,0) may or may not lie in element E.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a valid Eigen scalar for field values. </td></tr>
    <tr><td class="paramname">MeshType</td><td>the type of the meshes: <a class="el" href="classdrake_1_1geometry_1_1_surface_mesh.html" title="SurfaceMesh represents a triangulated surface.">SurfaceMesh</a> or <a class="el" href="classdrake_1_1geometry_1_1_volume_mesh.html" title="VolumeMesh represents a tetrahedral volume mesh.">VolumeMesh</a>. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;drake/geometry/proximity/mesh_field_linear.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a95cb1c6952612163b7e60a81a209f692"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#a95cb1c6952612163b7e60a81a209f692">MeshFieldLinear</a> (std::string <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#ad8227ba86a01f26e4f173cd5e219d5d1">name</a>, std::vector&lt; T &gt; &amp;&amp;<a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#ab061f844471bd39fe7260db6700079aa">values</a>, const MeshType *<a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#ac41d1bc48208a47ffceb25d417eea442">mesh</a>, bool calculate_gradient=true)</td></tr>
<tr class="memdesc:a95cb1c6952612163b7e60a81a209f692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>.  <a href="#a95cb1c6952612163b7e60a81a209f692">More...</a><br /></td></tr>
<tr class="separator:a95cb1c6952612163b7e60a81a209f692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2859db3356af45da7e6da8c343f938d"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#af2859db3356af45da7e6da8c343f938d">EvaluateAtVertex</a> (typename MeshType::VertexIndex v) const final</td></tr>
<tr class="memdesc:af2859db3356af45da7e6da8c343f938d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the field value at a vertex.  <a href="#af2859db3356af45da7e6da8c343f938d">More...</a><br /></td></tr>
<tr class="separator:af2859db3356af45da7e6da8c343f938d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4714ec5e80d27f062888ebb4b9ab8c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#aaa4714ec5e80d27f062888ebb4b9ab8c">Evaluate</a> (typename MeshType::ElementIndex e, const typename MeshType::Barycentric &amp;b) const final</td></tr>
<tr class="memdesc:aaa4714ec5e80d27f062888ebb4b9ab8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the field value at a location on an element.  <a href="#aaa4714ec5e80d27f062888ebb4b9ab8c">More...</a><br /></td></tr>
<tr class="separator:aaa4714ec5e80d27f062888ebb4b9ab8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6db0934f6f8d44eabf7e27caa46f6f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#aee6db0934f6f8d44eabf7e27caa46f6f">EvaluateCartesian</a> (typename MeshType::ElementIndex e, const typename MeshType::Cartesian &amp;p_MQ) const final</td></tr>
<tr class="memdesc:aee6db0934f6f8d44eabf7e27caa46f6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the field at a point Qp on an element.  <a href="#aee6db0934f6f8d44eabf7e27caa46f6f">More...</a><br /></td></tr>
<tr class="separator:aee6db0934f6f8d44eabf7e27caa46f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91da100f3b62c33232b5e43f24094ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#aa91da100f3b62c33232b5e43f24094ee">EvaluateGradient</a> (typename MeshType::ElementIndex e) const</td></tr>
<tr class="memdesc:aa91da100f3b62c33232b5e43f24094ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the gradient in the domain of the element indicated by <code>e</code>.  <a href="#aa91da100f3b62c33232b5e43f24094ee">More...</a><br /></td></tr>
<tr class="separator:aa91da100f3b62c33232b5e43f24094ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efe5031ed37c58f673e62568b8b0e22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#a8efe5031ed37c58f673e62568b8b0e22">TransformGradients</a> (const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; typename MeshType::ScalarType &gt; &amp;X_NM)</td></tr>
<tr class="memdesc:a8efe5031ed37c58f673e62568b8b0e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the gradient vectors of this field from its initial frame M to the new frame N.  <a href="#a8efe5031ed37c58f673e62568b8b0e22">More...</a><br /></td></tr>
<tr class="separator:a8efe5031ed37c58f673e62568b8b0e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8227ba86a01f26e4f173cd5e219d5d1"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#ad8227ba86a01f26e4f173cd5e219d5d1">name</a> () const</td></tr>
<tr class="separator:ad8227ba86a01f26e4f173cd5e219d5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab061f844471bd39fe7260db6700079aa"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#ab061f844471bd39fe7260db6700079aa">values</a> () const</td></tr>
<tr class="separator:ab061f844471bd39fe7260db6700079aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d580298a19542b95e2d823834bb63f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#a35d580298a19542b95e2d823834bb63f">Equal</a> (const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a>&lt; T, MeshType &gt; &amp;field) const</td></tr>
<tr class="memdesc:a35d580298a19542b95e2d823834bb63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> object is equal via deep exact comparison.  <a href="#a35d580298a19542b95e2d823834bb63f">More...</a><br /></td></tr>
<tr class="separator:a35d580298a19542b95e2d823834bb63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Implements CopyConstructible, CopyAssignable, MoveConstructible, MoveAssignable</div></td></tr>
<tr class="memitem:a39db892a867c3f6cd3449eb140751586"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#a39db892a867c3f6cd3449eb140751586">MeshFieldLinear</a> (const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> &amp;)=default</td></tr>
<tr class="separator:a39db892a867c3f6cd3449eb140751586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa215f756d02e682e0577a0bf1d63fd49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#aa215f756d02e682e0577a0bf1d63fd49">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> &amp;)=default</td></tr>
<tr class="separator:aa215f756d02e682e0577a0bf1d63fd49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6305717a210ca72f5f27a23aa0717f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#ada6305717a210ca72f5f27a23aa0717f">MeshFieldLinear</a> (<a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ada6305717a210ca72f5f27a23aa0717f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8235f4043f16f99b11bb7b62b16958d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#a8235f4043f16f99b11bb7b62b16958d3">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a8235f4043f16f99b11bb7b62b16958d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classdrake_1_1geometry_1_1_mesh_field"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classdrake_1_1geometry_1_1_mesh_field')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField&lt; T, MeshType &gt;</a></td></tr>
<tr class="memitem:a5cb2622bbd714f4580f4eee6923918e9 inherit pub_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#a5cb2622bbd714f4580f4eee6923918e9">~MeshField</a> ()=default</td></tr>
<tr class="separator:a5cb2622bbd714f4580f4eee6923918e9 inherit pub_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393422b04d1b4f1b2a1079859c50e5db inherit pub_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#a393422b04d1b4f1b2a1079859c50e5db">CloneAndSetMesh</a> (const MeshType *new_mesh) const</td></tr>
<tr class="memdesc:a393422b04d1b4f1b2a1079859c50e5db inherit pub_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to a new MeshField and set the new MeshField to use a new compatible mesh.  <a href="classdrake_1_1geometry_1_1_mesh_field.html#a393422b04d1b4f1b2a1079859c50e5db">More...</a><br /></td></tr>
<tr class="separator:a393422b04d1b4f1b2a1079859c50e5db inherit pub_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41d1bc48208a47ffceb25d417eea442 inherit pub_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top">const MeshType &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#ac41d1bc48208a47ffceb25d417eea442">mesh</a> () const</td></tr>
<tr class="separator:ac41d1bc48208a47ffceb25d417eea442 inherit pub_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classdrake_1_1geometry_1_1_mesh_field')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField&lt; T, MeshType &gt;</a></td></tr>
<tr class="memitem:a92126f12819144fdb857a8ac7b9cefa6 inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#a92126f12819144fdb857a8ac7b9cefa6">MeshField</a> (const MeshType *<a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#ac41d1bc48208a47ffceb25d417eea442">mesh</a>)</td></tr>
<tr class="separator:a92126f12819144fdb857a8ac7b9cefa6 inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb51440efbe76ac3cb6bdd73d3e9ffea inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#adb51440efbe76ac3cb6bdd73d3e9ffea">CloneWithNullMesh</a> () const</td></tr>
<tr class="separator:adb51440efbe76ac3cb6bdd73d3e9ffea inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e49571663226cd1e38814bbbf694fd inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#a24e49571663226cd1e38814bbbf694fd">MeshField</a> (const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a> &amp;)=default</td></tr>
<tr class="separator:a24e49571663226cd1e38814bbbf694fd inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93026efaa71a0733107fa17ade2a7ae2 inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#a93026efaa71a0733107fa17ade2a7ae2">MeshField</a> (<a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a93026efaa71a0733107fa17ade2a7ae2 inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00796751b31ab4982598a6793405d855 inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#a00796751b31ab4982598a6793405d855">operator=</a> (const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a> &amp;)=default</td></tr>
<tr class="separator:a00796751b31ab4982598a6793405d855 inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac195e2980026fcd3efd2a9920056c35e inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#ac195e2980026fcd3efd2a9920056c35e">operator=</a> (<a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a> &amp;&amp;)=default</td></tr>
<tr class="separator:ac195e2980026fcd3efd2a9920056c35e inherit pro_methods_classdrake_1_1geometry_1_1_mesh_field"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a39db892a867c3f6cd3449eb140751586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39db892a867c3f6cd3449eb140751586">&#9670;&nbsp;</a></span>MeshFieldLinear() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt; T, MeshType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ada6305717a210ca72f5f27a23aa0717f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6305717a210ca72f5f27a23aa0717f">&#9670;&nbsp;</a></span>MeshFieldLinear() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt; T, MeshType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95cb1c6952612163b7e60a81a209f692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cb1c6952612163b7e60a81a209f692">&#9670;&nbsp;</a></span>MeshFieldLinear() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a> </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshType *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>calculate_gradient</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the field variable. </td></tr>
    <tr><td class="paramname">values</td><td>The field value at each vertex of the mesh. </td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh M to which this <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html" title="MeshField is an abstract class that represents a field variable defined on a mesh M.">MeshField</a> refers. </td></tr>
    <tr><td class="paramname">calculate_gradient</td><td>Calculate gradient field when true, default is true. Calculating gradient allows <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#aee6db0934f6f8d44eabf7e27caa46f6f" title="Evaluates the field at a point Qp on an element.">EvaluateCartesian()</a> to evaluate the field directly instead of converting Cartesian coordinates to barycentric coordinates first. If calculate_gradient is false, <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html#aee6db0934f6f8d44eabf7e27caa46f6f" title="Evaluates the field at a point Qp on an element.">EvaluateCartesian()</a> will be slower. On the other hand, calculating gradient requires certain quality from mesh elements. If the mesh quality is very poor, calculating gradient may throw. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>mesh</code> is non-null, and the number of entries in <code>values</code> is the same as the number of vertices of the mesh. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35d580298a19542b95e2d823834bb63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d580298a19542b95e2d823834bb63f">&#9670;&nbsp;</a></span>Equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html">MeshField</a>&lt; T, MeshType &gt; &amp;&#160;</td>
          <td class="paramname"><em>field</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see whether the given <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a> object is equal via deep exact comparison. </p>
<p>The name of the objects are exempt from this comparison. NaNs are treated as not equal as per the IEEE standard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The field for comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the given field is equal. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Requires <code><a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html" title="MeshField is an abstract class that represents a field variable defined on a mesh M.">MeshField</a> field</code> to be <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html" title="MeshFieldLinear represents a continuous piecewise-linear scalar field f defined on a (triangular or t...">MeshFieldLinear</a>. </dd></dl>

</div>
</div>
<a id="aaa4714ec5e80d27f062888ebb4b9ab8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4714ec5e80d27f062888ebb4b9ab8c">&#9670;&nbsp;</a></span>Evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T Evaluate </td>
          <td>(</td>
          <td class="paramtype">typename MeshType::ElementIndex&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType::Barycentric &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the field value at a location on an element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The index of the element. </td></tr>
    <tr><td class="paramname">b</td><td>The barycentric coordinates. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#ac6bac3cbb8bdeeb8915c41147de04ae1">MeshField&lt; T, MeshType &gt;</a>.</p>

</div>
</div>
<a id="af2859db3356af45da7e6da8c343f938d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2859db3356af45da7e6da8c343f938d">&#9670;&nbsp;</a></span>EvaluateAtVertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T EvaluateAtVertex </td>
          <td>(</td>
          <td class="paramtype">typename MeshType::VertexIndex&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the field value at a vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The index of the vertex. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#a21ab8751318d7180e5dafa3c1bdd4c83">MeshField&lt; T, MeshType &gt;</a>.</p>

</div>
</div>
<a id="aee6db0934f6f8d44eabf7e27caa46f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6db0934f6f8d44eabf7e27caa46f6f">&#9670;&nbsp;</a></span>EvaluateCartesian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T EvaluateCartesian </td>
          <td>(</td>
          <td class="paramtype">typename MeshType::ElementIndex&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename MeshType::Cartesian &amp;&#160;</td>
          <td class="paramname"><em>p_MQ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the field at a point Qp on an element. </p>
<p>If the element is a tetrahedron, Qp is the input point Q. If the element is a triangle, Qp is the projection of Q on the triangle's plane.</p>
<p>If gradients have been calculated, it evaluates the field value directly. Otherwise, it converts Cartesian coordinates to barycentric coordinates for barycentric interpolation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The index of the element. </td></tr>
    <tr><td class="paramname">p_MQ</td><td>The position of point Q expressed in frame M, in Cartesian coordinates. M is the frame of the mesh. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classdrake_1_1geometry_1_1_mesh_field.html#ae58e0fc807e0c78b697da070d662ec3b">MeshField&lt; T, MeshType &gt;</a>.</p>

</div>
</div>
<a id="aa91da100f3b62c33232b5e43f24094ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91da100f3b62c33232b5e43f24094ee">&#9670;&nbsp;</a></span>EvaluateGradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacedrake.html#a0ad29daab565ce347c4d1c5aae6a76c2">Vector3</a>&lt;T&gt; EvaluateGradient </td>
          <td>(</td>
          <td class="paramtype">typename MeshType::ElementIndex&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the gradient in the domain of the element indicated by <code>e</code>. </p>
<p>The gradient is a vector in R³ expressed in frame M. For surface meshes, it will particularly lie parallel to the plane of the corresponding triangle. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the gradient vector was not calculated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8227ba86a01f26e4f173cd5e219d5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8227ba86a01f26e4f173cd5e219d5d1">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8235f4043f16f99b11bb7b62b16958d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8235f4043f16f99b11bb7b62b16958d3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt; T, MeshType &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa215f756d02e682e0577a0bf1d63fd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa215f756d02e682e0577a0bf1d63fd49">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a>&lt; T, MeshType &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8efe5031ed37c58f673e62568b8b0e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efe5031ed37c58f673e62568b8b0e22">&#9670;&nbsp;</a></span>TransformGradients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TransformGradients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdrake_1_1math_1_1_rigid_transform.html">math::RigidTransform</a>&lt; typename MeshType::ScalarType &gt; &amp;&#160;</td>
          <td class="paramname"><em>X_NM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the gradient vectors of this field from its initial frame M to the new frame N. </p>
<dl class="section warning"><dt>Warning</dt><dd>Use this function when the reference mesh of this field changes its frame in the same way. </dd></dl>

</div>
</div>
<a id="ab061f844471bd39fe7260db6700079aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab061f844471bd39fe7260db6700079aa">&#9670;&nbsp;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;T&gt;&amp; values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drake/geometry/proximity/<a class="el" href="mesh__field__linear_8h.html">mesh_field_linear.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15 -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedrake.html">drake</a></li><li class="navelem"><a class="el" href="namespacedrake_1_1geometry.html">geometry</a></li><li class="navelem"><a class="el" href="classdrake_1_1geometry_1_1_mesh_field_linear.html">MeshFieldLinear</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.nl/">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a></li>
  </ul>
</div>
</body>
</html>
